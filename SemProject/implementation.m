% Generate Controller for Quadrotor (Force, Position Optimal Control)
% Generated by Darivianakis Georgios (gdarivia@student.ethz.ch)

close all
clear all
clear classes
clc
%% Parameters Initialization
m = 0.650;
g = 9.8065;
l = 0.30;
gamma = 0;
J = m*l*l/4; % Inertia, we use the approximation of Thin, solid disk of radius r and mass m

TsCtrl = 0.08;
TsReal = 0.01;

DF_roll = 0;
a1_roll = 54.9;
a0_roll = 419.1;
c0_roll = 419.1;

DF_pitch = 0;
a1_pitch = 59.71;
a0_pitch = 491;
c0_pitch = 491;

a0_yaw = 5.9;
c0_yaw = 5.9;

Theta = -deg2rad(3); % Docking angle

% Optimization Parameters
N = 5;
norm = 2;

%% Xdirection Controller (Pitch Controller)

modelXdirection = GenerateModel('QuadXDirection',Theta,TsCtrl,m,l,gamma,J,a1_pitch,a0_pitch,c0_pitch,DF_pitch);
% Simulation Model
modelXdirectionReal = GenerateModel('QuadXDirectionSimulink',Theta,TsReal,m,l,gamma,J,a1_pitch,a0_pitch,c0_pitch,DF_pitch);

%

% %%  Simulate Open Loop
% x0 = [0 0 -0.1 0 ]';
% modelXdirection.initialize(x0);
% 
% U = -deg2rad(5)*ones(1,50);
% data = modelXdirection.simulate(U);
% 
% time = [0:Ts:49*Ts];
% figure(1);
% subplot(5,1,1)
% plot(time,data.Y(1,:)); grid on;ylabel('angle');
% subplot(5,1,2)
% plot(time,data.Y(2,:)); grid on;ylabel('omega');
% subplot(5,1,3)
% plot(time,data.Y(3,:)); grid on;ylabel('position')
% subplot(5,1,4)
% plot(time,data.Y(4,:)); grid on;ylabel('velocity')
% subplot(5,1,5)
% plot(time,data.Y(5,:)); grid on;ylabel('Force')

% Optimization problem set up
Qy = zeros(5,5);
Qy(3,3) = 100; % when we have the switching this cost will be zero.
Qy(4,4) = 10;
Qy(5,5) = 1; % when in free flight this error doesn't affect optimization
R = 1;
Q = zeros(4,4);
% reference signals calculation Xss = A*Xss+B*Uref
yref = [Theta;0;0;0;-m*g*Theta]; % ensure that the angle of arrival is not positive 
xref = [Theta;0;0;0];
B = modelXdirection.B{1};
A = modelXdirection.A{1};
uref = (B'*B)\B'*(eye(4) - A)*xref;

ctrl = MPCController(modelXdirection);
ctrl.N = N;

% add quadratic penalty on the inputs
ctrl.model.u.penalty = Penalty(R, norm);
% add quadratic penalty on the states
ctrl.model.x.penalty = Penalty(Q, norm);
% add quadratic penalty on the output
ctrl.model.y.penalty = Penalty(Qy, norm);

% Define output reference signal
ctrl.model.y.with('reference');
ctrl.model.y.reference = yref;
ctrl.model.u.with('reference');
ctrl.model.u.reference = uref;

% Define Terminal Set
% ctrl.model.x.with('terminalSet');
% ctrl.model.x.terminalSet = Polyhedron('Ae',Ae,'be',be);
expmpcXdirection = ctrl.toExplicit();
% Create Look Up Table, code in C
exportToC_MLD(expmpcXdirection,TsCtrl,'XdirectionCtrl','Xdirection');
cd Xdirection
mex mpt_getInput_sfunc_Xdirection.c;
cd ..
[Hn_Xdir,Kn_Xdir,Fi_Xdir,Gi_Xdir,Nc_Xdir] = GetMPCMatrices(expmpcXdirection);
save('Xdirection','Hn_Xdir','Kn_Xdir','Fi_Xdir','Gi_Xdir','Nc_Xdir');
x0 = [0;0;-1;0];


% Simulate the closed loop
% N_sim = 50;
% 
% % Create the closed-loop system:
% loop = ClosedLoop(expmpc, modelXdirection);
% ClosedData = loop.simulate(x0, N_sim);
% 
% N = size(ClosedData.Y(1,:),2);
% time = zeros(N,1);
% Fref = zeros(N,1);
% thetaref = zeros(N,1);
% k=1;
% for i = 0:Ts:(N-1)*Ts
%     time(k) =i;
%     Fref(k) = yref(5);
%     thetaref(k) = yref(1);
%     k = k+1;
% end
% 
% 
% % plot the output
% figure(2);
% subplot(6,1,1)
% plot(time,ClosedData.Y(1,:),time,thetaref,'-g'); grid on;ylabel('angle');
% subplot(6,1,2)
% plot(time,ClosedData.Y(2,:)); grid on;ylabel('omega');
% subplot(6,1,3)
% plot(time,ClosedData.Y(3,:)); grid on;ylabel('position')
% subplot(6,1,4)
% plot(time,ClosedData.Y(4,:)); grid on;ylabel('velocity')
% subplot(6,1,5)
% plot(time,ClosedData.Y(5,:),time,Fref,'-g'); grid on;ylabel('Force')
% subplot(6,1,6)
% plot(time,ClosedData.U(:)); grid on;ylabel('Input')

%% Xdirection Controller Free Flight
Af = zeros(4,4);
Bf = zeros(4,1);
Df = zeros(4,1);
% Free Flight
Af(1,2) = 1; Af(2,1) = -a0_pitch; Af(2,2) = -a1_pitch; Af(3,4) = 1; 
Af(4,1) = -g; Af(4,4) = DF_pitch;
Bf(2,1) = c0_pitch;
Cf = eye(4);

sysfc = ss(Af,Bf,Cf,Df);

% All controller must operate at the same frequency
sysfd = c2d(sysfc,TsCtrl,'zoh');
modelXdirectionFF = LTISystem(sysfd);

% Real models are generated at 50Hz frequency
sysfd = c2d(sysfc,TsReal,'zoh');
modelXdirectionRealFF = LTISystem(sysfd);

% Set constraints on states and input
modelXdirectionFF.x.min = [-0.2094;-2;-1;-1];
modelXdirectionFF.x.max = [0.2094;2;1;1];
modelXdirectionFF.u.min = -0.27;
modelXdirectionFF.u.max = 0.27;

% Set the penalty
Qxff = zeros(4,4);
Qxff(1,1) = 10;
Qxff(3,3) = 100; % position control
Qxff(4,4) = 10;
Rff = 40;

modelXdirectionFF.x.penalty = Penalty(Qxff,norm);
modelXdirectionFF.u.penalty = Penalty(Rff,norm);

ctrlXFF = MPCController(modelXdirectionFF,N);

expmpcXdirectionFF = ctrlXFF.toExplicit;
exportToC_MLD(expmpcXdirectionFF,TsCtrl,'XdirectionCtrlFF','XdirectionFF');
cd XdirectionFF
mex mpt_getInput_sfunc_XdirectionFF.c;
cd ..
[Hn_XdirFF,Kn_XdirFF,Fi_XdirFF,Gi_XdirFF,Nc_XdirFF] = GetMPCMatrices(expmpcXdirectionFF);
save('XdirectionFF','Hn_XdirFF','Kn_XdirFF','Fi_XdirFF','Gi_XdirFF','Nc_XdirFF');
x0FF = [0;0;-1;0];


% %Simulate the closed loop
% N_sim = 50;
% 
% %Create the closed-loop system:
% loop = ClosedLoop(expmpcXdirectionFF, modelXdirectionFF);
% ClosedData = loop.simulate(x0FF, N_sim);
% 
% yref = [0;0;0;0];
% N = size(ClosedData.Y(1,:),2);
% time = zeros(N,1);
% Fref = zeros(N,1);
% thetaref = zeros(N,1);
% k=1;
% for i = 0:Ts:(N-1)*Ts
%     time(k) =i;
%     Fref(k) = yref(4);
%     thetaref(k) = yref(1);
%     k = k+1;
% end
% 
% 
% %plot the output
% figure(3);
% subplot(5,1,1)
% plot(time,ClosedData.Y(1,:),time,thetaref,'-g'); grid on;ylabel('angle');
% subplot(5,1,2)
% plot(time,ClosedData.Y(2,:)); grid on;ylabel('omega');
% subplot(5,1,3)
% plot(time,ClosedData.Y(3,:)); grid on;ylabel('position')
% subplot(5,1,4)
% plot(time,ClosedData.Y(4,:)); grid on;ylabel('velocity')
% subplot(5,1,5)
% plot(time,ClosedData.U(:)); grid on;ylabel('Input')

%% Ydirection Controller (No Hybrid Model) (Roll Controller)
%DF = -0.9606;

Af = zeros(4,4);
Bf = zeros(4,1);
Df = zeros(4,1);
% Free Flight
Af(1,2) = 1; Af(2,1) = -a0_roll; Af(2,2) = -a1_roll; Af(3,4) = 1; 
Af(4,1) = g; Af(4,4) = DF_roll;
Bf(2,1) = c0_roll;
Cf = eye(4);

sysfc = ss(Af,Bf,Cf,Df);

% All controller must operate at the same frequency
sysfd = c2d(sysfc,TsCtrl,'zoh');
modelYdirection = LTISystem(sysfd);

% Real models are generated at 50Hz frequency
sysfd = c2d(sysfc,TsReal,'zoh');
modelYdirectionReal = LTISystem(sysfd);

% Set constraints on states and input
modelYdirection.x.min = [-0.2094;-2;-1;-1];
modelYdirection.x.max = [0.2094;2;1;1];
modelYdirection.u.min = -0.27;
modelYdirection.u.max = 0.27;

% Set the penalty
Qxy = zeros(4,4);
Qxy(1,1) = 10;
Qxy(3,3) = 100; % position control
Qxy(4,4) = 10;
Ry = 40;

modelYdirection.x.penalty = Penalty(Qxy,norm);
modelYdirection.u.penalty = Penalty(Ry,norm);

ctrlY = MPCController(modelYdirection,N);

expmpcYdirection = ctrlY.toExplicit;
exportToC_MLD(expmpcYdirection,TsCtrl,'YdirectionCtrl','Ydirection');
cd Ydirection
mex mpt_getInput_sfunc_Ydirection.c;
cd ..
[Hn_Ydir,Kn_Ydir,Fi_Ydir,Gi_Ydir,Nc_Ydir] = GetMPCMatrices(expmpcYdirection);
save('Ydirection','Hn_Ydir','Kn_Ydir','Fi_Ydir','Gi_Ydir','Nc_Ydir');
y0 = [0;0;-1;0];


% %Simulate the closed loop
% N_sim = 50;
% 
% %Create the closed-loop system:
% loop = ClosedLoop(expmpcYdirection, modelYdirection);
% ClosedData = loop.simulate(y0, N_sim);
% 
% yref = [0;0;0;0];
% N = size(ClosedData.Y(1,:),2);
% time = zeros(N,1);
% Fref = zeros(N,1);
% thetaref = zeros(N,1);
% k=1;
% for i = 0:Ts:(N-1)*Ts
%     time(k) =i;
%     Fref(k) = yref(4);
%     thetaref(k) = yref(1);
%     k = k+1;
% end
% 
% 
% %plot the output
% figure(3);
% subplot(5,1,1)
% plot(time,ClosedData.Y(1,:),time,thetaref,'-g'); grid on;ylabel('angle');
% subplot(5,1,2)
% plot(time,ClosedData.Y(2,:)); grid on;ylabel('omega');
% subplot(5,1,3)
% plot(time,ClosedData.Y(3,:)); grid on;ylabel('position')
% subplot(5,1,4)
% plot(time,ClosedData.Y(4,:)); grid on;ylabel('velocity')
% subplot(5,1,5)
% plot(time,ClosedData.U(:)); grid on;ylabel('Input')

%% Zdirection Controller (No Hybrid Model) (Thrust controller)

Az = zeros(2,2); Az(1,2) = 1;
Bz = zeros(2,1); Bz(2,1) = -1/m;
Cz = eye(2); Dz = 0;

syscz = ss(Az,Bz,Cz,Dz);

% All controller must operate at the same frequency
sysdz = c2d(syscz,TsCtrl,'zoh');
modelZdirection = LTISystem(sysdz);

% Real models are generated at 50Hz frequency
sysdz = c2d(syscz,TsReal,'zoh');
modelZdirectionReal = LTISystem(sysdz);

% Set constraints on states and input
modelZdirection.x.min = [-1;-1];
modelZdirection.x.max = [1;1];
modelZdirection.u.min = -1;
modelZdirection.u.max = 1;

% Set the penalty
Qxz = zeros(2,2);
Qxz(1,1) = 100; % position control
Qxz(2,2) = 15;
Rz = 4;

modelZdirection.x.penalty = Penalty(Qxz,norm);
modelZdirection.u.penalty = Penalty(Rz,norm);

ctrlZ = MPCController(modelZdirection,N);

expmpcZdirection = ctrlZ.toExplicit;
exportToC_MLD(expmpcZdirection,TsCtrl,'ZdirectionCtrl','Zdirection');
cd Zdirection
mex mpt_getInput_sfunc_Zdirection.c;
cd ..
[Hn_Zdir,Kn_Zdir,Fi_Zdir,Gi_Zdir,Nc_Zdir] = GetMPCMatrices(expmpcZdirection);
save('Zdirection','Hn_Zdir','Kn_Zdir','Fi_Zdir','Gi_Zdir','Nc_Zdir');
z0 = [-1;0];


% %Simulate the closed loop
% N_sim = 50;
% 
% % Create the closed-loop system:
% loop = ClosedLoop(expmpcZdirection, modelZdirection);
% ClosedData = loop.simulate(z0, N_sim);
% 
% N = size(ClosedData.Y(1,:),2);
% time = 0:Ts:(N-1)*Ts;
% 
% % plot the output
% figure(4);
% subplot(3,1,1)
% plot(time,ClosedData.Y(1,:)); grid on;ylabel('position')
% subplot(3,1,2)
% plot(time,ClosedData.Y(2,:)); grid on;ylabel('velocity')
% subplot(3,1,3)
% plot(time,ClosedData.U(:)); grid on;ylabel('Input')

%% (Yaw controller)

Ay = -a0_yaw;
By = c0_yaw;
Cy = 1;
Dy = 0;

syscy = ss(Ay,By,Cy,Dy);

% All controller must operate at the same frequency
sysdy = c2d(syscy,TsCtrl,'zoh');
modelYaw = LTISystem(sysdy);

% Real models are generated at 50Hz frequency
sysdy = c2d(syscy,TsReal,'zoh');
modelYawReal = LTISystem(sysdy);

% Set constraints on states and input
modelYaw.x.min = -pi;
modelYaw.x.max = pi;
modelYaw.u.min = -pi;
modelYaw.u.max = pi;

% Set the penalty
Qxy= 100; % yaw angle control
Ry = 1;

modelYaw.x.penalty = Penalty(Qxy,norm);
modelYaw.u.penalty = Penalty(Ry,norm);

ctrlYaw = MPCController(modelYaw,N);

expmpcYaw = ctrlYaw.toExplicit;
exportToC_MLD(expmpcYaw,TsCtrl,'YawCtrl','YawControl');
cd YawControl
mex mpt_getInput_sfunc_YawCtrl.c;
cd ..
[Hn_Yaw,Kn_Yaw,Fi_Yaw,Gi_Yaw,Nc_Yaw] = GetMPCMatrices(expmpcYaw);
save('Yawdirection','Hn_Yaw','Kn_Yaw','Fi_Yaw','Gi_Yaw','Nc_Yaw');
yaw0 = -0.0873;


% %Simulate the closed loop
% N_sim = 50;
% 
% % Create the closed-loop system:
% loop = ClosedLoop(expmpcYaw, modelYaw);
% ClosedData = loop.simulate(yaw0, N_sim);
% 
% N = size(ClosedData.Y(1,:),2);
% time = 0:Ts:(N-1)*Ts;
% 
% % plot the output
% figure(4);
% subplot(2,1,1)
% plot(time,ClosedData.Y(1,:)); grid on;ylabel('position')
% subplot(2,1,2)
% plot(time,ClosedData.U(:)); grid on;ylabel('Input')