% Generate Controller for Quadrotor (Force, Position Optimal Control)
% Generated by Darivianakis Georgios (gdarivia@student.ethz.ch)

close all
clear all
clear classes
tbxmanager restorepath
mpt_init
clc
% Parameters Initialization
m = 0.66;
g = 9.8065;
l = 0.30;
gamma = 0;
J = m*l*l/4; % Inertia, we use the approximation of Thin, solid disk of radius r and mass m

TsCtrl = 0.08;  % Sampling time of the controller
TsReal = 0.02;  % Sampling time of real system

% Dynamics for roll (y - direction)

DF_roll_DC= -0.05;   % Damping due to the contact in the wall
DF_roll_FF = 0;     % Free flight no damping


a1_roll = 27.07;    % Common parameters in both docking and free flight
a0_roll = 171.66;
c0_roll = 169.16;


% Dynamics for z direction
DF_z_FF = -3.4586;
DF_z_DC = -3.9586;

% Pitch dynamics x direction
DF_pitch = 0;
a1_pitch = 27.07;
a0_pitch = 171.66;
c0_pitch = 169.16;

a0_yaw = 5.9;
c0_yaw = 5.9;

Theta = -deg2rad(2); % Docking angle

% Optimization Parameters
N = 3; %N = 5; 
norm = 2;

%%

%%
%------------------------------------------------------------
%------------------------------------------------------------
% XYdirection Controller
%------------------------------------------------------------
%------------------------------------------------------------

% Initialize models of free-flight and docking
A = zeros(4,4);
B = zeros(4,2);
C = zeros(5,4);
D = zeros(5,2);

% Free Flight
A(1,2) = 1; 
A(2,2) = -DF_pitch;
A(3,4) = 1;
A(4,4) = -DF_roll_FF;

B(2,1) = -g;
B(4,2) = g;

C(1,1) = 1;
C(2,2) = 1;
C(4,3) = 1;
C(5,4) = 1;

  
Af = A;
Bf = B;
Cf = C;
Df = D;

% Free Flight model
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynFF = LTISystem(sysfd);
dynFF.setDomain('x', Polyhedron([1 0 0 0], -0.01));


% Docking

% Docking model

A(2,2) = 0;
A(4,4) = -DF_roll_DC;

B(2,1) = 0;

D(3,1) = -m*g;

Ad = A;
Bd = B;
Cd = C;
Dd = D;

sysfc = ss(Ad,Bd,Cd,Dd);
sysfd = c2d(sysfc,TsCtrl,'zoh');
% hacking for the position of the wall x = 0 and dot_x = 0
sysfd.a(1:2,1:2) = zeros(2,2);

dynDC = LTISystem(sysfd);
dynDC.setDomain('x', Polyhedron([-1 0 0 0], 0.01));


modelXYdirection = PWASystem([dynDC dynFF]);
% Set constraints on states and input
modelXYdirection.x.min = [-1;-1;-1;-1];  % states x = [x, x_dot, y, y_dot]
modelXYdirection.x.max = [0;1;1;1];
modelXYdirection.u.min = [-0.27;-0.27];   
modelXYdirection.u.max = [0.27;0.27];

%% X-Y direction Optimization Problem Set Up

% Reference Signal Calculation
% Output Reference
yref = [0;0;-m*g*Theta;0;0];    % yref = [x, x_dot,Fwall, y, y_dot]
xref = zeros(4,1);   % xref  = [x, x_dot, y, y_dot]

B = modelXYdirection.B{2};
A = modelXYdirection.A{2};
uref = (B'*B)\B'*(eye(size(A,1)) - A)*xref;

% Output reference tracking
Qxy = zeros(5,5); 
Qxy(1,1) = 55;
Qxy(2,2) = 8;
Qxy(3,3) = 50;
Qxy(4,4) = 150; 
Qxy(5,5) = 20;

R = diag([40;40]);
Q = zeros(4,4);

ctrl = MPCController(modelXYdirection);
ctrl.N = N;

% add quadratic penalty on the inputs
ctrl.model.u.penalty = Penalty(R, norm);
% add quadratic penalty on the states
ctrl.model.x.penalty = Penalty(Q, norm);
% add quadratic penalty on the output
ctrl.model.y.penalty = Penalty(Qxy, norm);

% Define output reference signal
ctrl.model.y.with('reference');
ctrl.model.y.reference = yref;
ctrl.model.u.with('reference');
ctrl.model.u.reference = uref;

%% Obstacle avoidance (Yalmip formulation)

% Relative distance for the controller
xrel_min = -0.4;
xrel_max = -0.3;
yrel_min = -0.4;
yrel_max = -0.3;

% Define the unsafe location

H = zeros(8,4);
H(1,1) = -1; H(2,1) = 1;
H(3,2) = -1; H(4,2) = 1;
H(5,3) = -1; H(6,3) = 1;
H(7,4) = -1; H(8,4) = 1;

K = zeros(8,1);
K(1) = -xrel_min; K(2) = xrel_max;
K(3:4) = 1;
K(5) = -yrel_min; K(6) = yrel_max;
K(7:8) = 1;

Punsafe = polytope(H, K);

% Define the total Space
H = zeros(8,4);
H(1,1) = -1; H(2,1) = 1;
H(3,2) = -1; H(4,2) = 1;
H(5,3) = -1; H(6,3) = 1;
H(7,4) = -1; H(8,4) = 1;

K = zeros(8,1);
K(1) = 1; K(2) = 0;
K(3:4) = 1;
K(5) = 1; K(6) = 1;
K(7:8) = 1;

Pspace = polytope(H,K);

% Define the safe space
Psafe = Pspace \ Punsafe;

%% Define constraint for the specific obstacle in x direction
Xyal = ctrl.toYALMIP();

for k = 1:size(Xyal.variables.x,2)
    Xyal.constraints = Xyal.constraints +...
        set(ismember(Xyal.variables.x(:,k), Psafe));
end

ctrl.fromYALMIP(Xyal);
%% Explicit Controller

expmpcXYdirection = ctrl.toExplicit();

%% Create Look Up Table, code in C
exportToC_MLD(expmpcXYdirection,TsCtrl,'XYdirectionCtrl','XYdirection');
cd XYdirection
mex mpt_getInput_sfunc_XYdirection.c;
cd ..

[Hn_XYdir,Kn_XYdir,Fi_XYdir,Gi_XYdir,Nc_XYdir] = GetMPCMatrices(expmpcXYdirection);
save('XYdirection','Hn_XYdir','Kn_XYdir','Fi_XYdir','Gi_XYdir','Nc_XYdir');

%% Closed Loop Simulation
loop = ClosedLoop(expmpcXYdirection,modelXYdirection);
x0 = [-1,0,-1,0]';
Nsim = 10;

data = loop.simulate(x0,Nsim);

% Plot X-Y


