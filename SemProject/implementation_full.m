% Generate Controller for Quadrotor (Force, Position Optimal Control)
% Generated by Darivianakis Georgios (gdarivia@student.ethz.ch)

close all
clear all
clear classes
tbxmanager restorepath
mpt_init
clc
% Parameters Initialization
m = 0.66;
g = 9.8065;
l = 0.30;
gamma = 0;
J = m*l*l/4; % Inertia, we use the approximation of Thin, solid disk of radius r and mass m

TsCtrl = 0.08;  % Sampling time of the controller
TsReal = 0.02;  % Sampling time of real system

% Dynamics for roll (y - direction)

DF_roll_DC= -0.05;   % Damping due to the contact in the wall
DF_roll_FF = 0;     % Free flight no damping


a1_roll = 27.07;    % Common parameters in both docking and free flight
a0_roll = 171.66;
c0_roll = 169.16;


% Dynamics for z direction
DF_z_FF = -3.4586;
DF_z_DC = -3.9586;

% Pitch dynamics x direction
DF_pitch = 0;
a1_pitch = 27.07;
a0_pitch = 171.66;
c0_pitch = 169.16;

a0_yaw = 5.9;
c0_yaw = 5.9;

Theta = -deg2rad(2); % Docking angle

% Optimization Parameters
N = 2; %N = 5; 
norm = 2;

%%
%------------------------------------------------------------
%------------------------------------------------------------
% Xdirection Controller (Pitch Controller)
%------------------------------------------------------------
%------------------------------------------------------------


modelXdirection = GenerateModel('QuadXDirectionNC',Theta,TsCtrl,m,l,gamma,J,a1_pitch,a0_pitch,c0_pitch,DF_pitch);

%%
%------------------------------------------------------------
%------------------------------------------------------------
% Ydirection Controller (Roll Controller)
%------------------------------------------------------------
%------------------------------------------------------------

% Initialize models of free-flight and docking
A = zeros(4,4);
B = zeros(4,1);

% Free Flight
A(1,2) = 1; A(2,1) = -a0_roll; A(2,2) = -a1_roll; A(3,4) = 1;
A(4,1) = g; A(4,4) = DF_roll_FF;

B(2,1) = c0_roll;


%  State  Extension to include external input
Af = A;
Bf = B;
Cf = eye(4);
Df = zeros(4,1);

% Free Flight model
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynFF = LTISystem(sysfd);


% Docking model
Af(4,4) = DF_roll_DC;
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynDC = LTISystem(sysfd);


modelYdirection = PWASystem([dynDC dynFF]);
% Set constraints on states and input
modelYdirection.x.min = [-0.2094;-2;-1;-1];  % states x = [roll, roll_dot, y, y_dot, dx]
modelYdirection.x.max = [0.2094;2;1;1];
modelYdirection.u.min = -0.27;   
modelYdirection.u.max = 0.27;


%% Create X-Y model

% Docked Dynamics
Add = [modelXdirection.A{1},zeros(4,4);zeros(4,4),modelYdirection.A{1}];
Bdd = [modelXdirection.B{1},zeros(4,1);zeros(4,1),modelYdirection.B{1}];
Cdd = [modelXdirection.C{1},zeros(5,4);zeros(4,4),modelYdirection.C{1}];
Ddd = 0;

DynDDXY = ss(Add,Bdd,Cdd,Ddd,TsCtrl);
DynDDXY = LTISystem(DynDDXY);
DynDDXY.setDomain('x', Polyhedron([0 0 -1 0 0 0 0 0], 0.01));

% Free Flight Dynamics
Aff = [modelXdirection.A{2},zeros(4,4);zeros(4,4),modelYdirection.A{2}];
Bff = [modelXdirection.B{2},zeros(4,1);zeros(4,1),modelYdirection.B{2}];
Cff = [modelXdirection.C{2},zeros(5,4);zeros(4,4),modelYdirection.C{2}];
Dff = 0;

DynFFXY = ss(Aff,Bff,Cff,Dff,TsCtrl);
DynFFXY = LTISystem(DynFFXY);
DynFFXY.setDomain('x', Polyhedron([0 0 1 0 0 0 0 0], -0.01));

modelXYdirection = PWASystem([DynFFXY DynDDXY]);

modelXYdirection.x.min = [-0.2094;-2;-1;-1;-0.2094;-2;-1;-1];  % states x = [pitch, pitch_dot, x, x_dot, roll, roll_dot, y, y_dot]
modelXYdirection.x.max = [0.2094;2;0;1;0.2094;2;1;1];
modelXYdirection.u.min = [-0.27;-0.27];   
modelXYdirection.u.max = [0.27;0.27];

%% X-Y direction Optimization Problem Set Up

% Reference Signal Calculation
% Output Reference
yref = [Theta;0;0;0;-m*g*Theta;0;0;0;0];    % yref = [pitch, pitch_dot, x, x_dot,Force, roll, roll_dot, y, y_dot]
xref = [Theta;0;0;0;0;0;0;0];               % xref  =[pitch, pitch_dot, x, x_dot, roll, roll_dot, y, y_dot]

B = modelXYdirection.B{2};
A = modelXYdirection.A{2};
uref = (B'*B)\B'*(eye(size(A,1)) - A)*xref;

% Output reference tracking
Qxy = zeros(9,9); 
Qxy(3,3) = 55;
Qxy(4,4) = 8;
Qxy(5,5) = 50;
Qxy(6,6) = 10;
Qxy(8,8) = 150; % position control  % 150
Qxy(9,9) = 20;

R = diag([40;40]);
Q = zeros(8,8);

ctrl = MPCController(modelXYdirection);
ctrl.N = N;

% add quadratic penalty on the inputs
ctrl.model.u.penalty = Penalty(R, norm);
% add quadratic penalty on the states
ctrl.model.x.penalty = Penalty(Q, norm);
% add quadratic penalty on the output
ctrl.model.y.penalty = Penalty(Qxy, norm);

% Define output reference signal
ctrl.model.y.with('reference');
ctrl.model.y.reference = yref;
ctrl.model.u.with('reference');
ctrl.model.u.reference = uref;

%% Obstacle avoidance (Yalmip formulation)

% Relative distance for the controller
xrel_min = -0.4;
xrel_max = -0.3;
yrel_min = -0.4;
yrel_max = -0.3;

% Define the unsafe location

H = zeros(16,8);
H(1,1) = -1; H(2,1) = 1;
H(3,2) = -1; H(4,2) = 1;
H(5,3) = -1; H(6,3) = 1;
H(7,4) = -1; H(8,4) = 1;
H(9,5) = -1; H(10,5) = 1;
H(11,6) = -1; H(12,6) = 1;
H(13,7) = -1; H(14,7) = 1;
H(15,8) = -1; H(16,8) = 1;

% modelXYdirection.x.min = [-0.2094;-2;-1;-1;-0.2094;-2;-1;1];  % states x = [pitch, pitch_dot, x, x_dot, roll, roll_dot, y, y_dot]
% modelXYdirection.x.max = [0.2094;2;0;1;0.2094;2;1;1];
% modelXYdirection.u.min = [-0.27;-0.27];   
% modelXYdirection.u.max = [0.27;0.27];


K = zeros(16,1);
K(1:2) = 0.2094;
K(3:4) = 2;
K(5) = -xrel_min; K(6) = xrel_max;
K(7:8) = 1;
K(9:10) = 0.2094;
K(11:12) = 2;
K(13) = -yrel_min; K(14) = yrel_max;
K(15:16) = 1;

Punsafe = polytope(H, K);

% Define the total Space
H = zeros(16,8);
H(1,1) = -1; H(2,1) = 1;
H(3,2) = -1; H(4,2) = 1;
H(5,3) = -1; H(6,3) = 1;
H(7,4) = -1; H(8,4) = 1;
H(9,5) = -1; H(10,5) = 1;
H(11,6) = -1; H(12,6) = 1;
H(13,7) = -1; H(14,7) = 1;
H(15,8) = -1; H(16,8) = 1;

K = zeros(16,1);
K(1:2) = 0.2094;
K(3:4) = 2;
K(5) = 1; K(6) = 0;
K(7:8) = 1;
K(9:10) = 0.2094;
K(11:12) = 2;
K(13) = 1; K(14) = 1;
K(15:16) = 1;

Pspace = polytope(H,K);

% Define the safe space
Psafe = Pspace \ Punsafe;

%% Define constraint for the specific obstacle in x direction
Xyal = ctrl.toYALMIP();
for k = 1:size(Xyal.variables.x,2)
    Xyal.constraints = Xyal.constraints +...
        set(ismember(Xyal.variables.x(:,k), Psafe));
end

ctrl.fromYALMIP(Xyal);
%%

expmpcXYdirection = ctrl.toExplicit();
%%

% Create Look Up Table, code in C
exportToC_MLD(expmpcXdirection,TsCtrl,'XdirectionCtrl','Xdirection');
cd Xdirection
mex mpt_getInput_sfunc_Xdirection.c;
cd ..
[Hn_Xdir,Kn_Xdir,Fi_Xdir,Gi_Xdir,Nc_Xdir] = GetMPCMatrices(expmpcXdirection);
save('Xdirection','Hn_Xdir','Kn_Xdir','Fi_Xdir','Gi_Xdir','Nc_Xdir');

%%
%------------------------------------------------------------
%------------------------------------------------------------
% Xdirection Controller (Free Flight) (Pitch Controller)
%------------------------------------------------------------
%------------------------------------------------------------


% Initialize models of free-flight and docking
Af = zeros(4,4);
Bf = zeros(4,1);

% Free Flight
Af(1,2) = 1; Af(2,1) = -a0_pitch; Af(2,2) = -a1_pitch; Af(3,4) = 1;
Af(4,1) = -g; Af(4,4) = DF_pitch;

Bf(2,1) = c0_pitch;

Cf = eye(4);
Df = zeros(4,1);


% Free Flight model
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynFF = LTISystem(sysfd);


modelXdirectionFF = dynFF;


% Set constraints on states and input
modelXdirectionFF.x.min = [-0.2094;-2;-1;-1];  % states x = [roll, roll_dot, y, y_dot, dx]
modelXdirectionFF.x.max = [0.2094;2;1;1];
modelXdirectionFF.u.min = -0.27;   
modelXdirectionFF.u.max = 0.27;

% Set the penalty (penalization remains the same, 4 outputs)
Qxy = zeros(4,4);
Qxy(1,1) = 10;
Qxy(3,3) = 80; % position control  % 100
Qxy(4,4) = 10;                      % 10

Ry = 40;

modelXdirectionFF.y.penalty = Penalty(Qxy,norm);  % output penalization 
modelXdirectionFF.u.penalty = Penalty(Ry,norm);

ctrlXFF = MPCController(modelXdirectionFF,N);


expmpcXdirectionFF = ctrlXFF.toExplicit;
exportToC_MLD(expmpcXdirectionFF,TsCtrl,'XdirectionCtrlFF','XdirectionFF');
cd XdirectionFF
mex mpt_getInput_sfunc_XdirectionFF.c;
cd ..
[Hn_XdirFF,Kn_XdirFF,Fi_XdirFF,Gi_XdirFF,Nc_XdirFF] = GetMPCMatrices(expmpcXdirectionFF);
save('XdirectionFF','Hn_XdirFF','Kn_XdirFF','Fi_XdirFF','Gi_XdirFF','Nc_XdirFF');



%%
%------------------------------------------------------------
%------------------------------------------------------------
% Ydirection Controller (No Hybrid Model) (Roll Controller)
%------------------------------------------------------------
%------------------------------------------------------------


% Initialize models of free-flight and docking
A = zeros(4,4);
B = zeros(4,1);

% Free Flight
A(1,2) = 1; A(2,1) = -a0_roll; A(2,2) = -a1_roll; A(3,4) = 1;
A(4,1) = g; A(4,4) = DF_roll_FF;

B(2,1) = c0_roll;


%  State  Extension to include external input
Af = [A,zeros(4,1);zeros(1,4),0];
Bf = [B;0];
Cf = [eye(4),zeros(4,1)];
Df = zeros(4,1);

% Free Flight model
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynFF = LTISystem(sysfd);

dynFF.setDomain('x', Polyhedron([0 0 0 0 1], 0));


% Docking model
Af(4,4) = DF_roll_DC;
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,TsCtrl,'zoh');
dynDC = LTISystem(sysfd);
dynDC.setDomain('x', Polyhedron([0 0 0 0 -1], 0));


modelYdirection = PWASystem([dynFF dynDC]);


% Set constraints on states and input
modelYdirection.x.min = [-0.2094;-2;-1;-1;-1];  % states x = [roll, roll_dot, y, y_dot, dx]
modelYdirection.x.max = [0.2094;2;1;1;0.5];
modelYdirection.u.min = -0.27;   
modelYdirection.u.max = 0.27;

% Set the penalty (penalization remains the same, 4 outputs)
Qxy = zeros(4,4);
Qxy(1,1) = 10;
Qxy(3,3) = 150; % position control  % 150
Qxy(4,4) = 20;                      % 20

Ry = 40;

modelYdirection.y.penalty = Penalty(Qxy,norm);  % output penalization 
modelYdirection.u.penalty = Penalty(Ry,norm);

ctrlY = MPCController(modelYdirection,N);


expmpcYdirection = ctrlY.toExplicit;
exportToC_MLD(expmpcYdirection,TsCtrl,'YdirectionCtrl','Ydirection');
cd Ydirection
mex mpt_getInput_sfunc_Ydirection.c;
cd ..
[Hn_Ydir,Kn_Ydir,Fi_Ydir,Gi_Ydir,Nc_Ydir] = GetMPCMatrices(expmpcYdirection);
save('Ydirection','Hn_Ydir','Kn_Ydir','Fi_Ydir','Gi_Ydir','Nc_Ydir');



%%
%------------------------------------------------------------
%------------------------------------------------------------
% Zdirection Controller (No Hybrid Model) (Thrust controller)
%------------------------------------------------------------
%------------------------------------------------------------

% Theoretical Values
% Az = zeros(2,2); Az(1,2) = 1; 
% Bz = zeros(2,1); Bz(2,1) = -1/m;
% Cz = eye(2); Dz = 0;

Tsz = 0.02;

%    - from ID - possibly wrong
A = [0 1; 0 DF_z_FF];
B = [0 -5.6961]';


%  State  Extension to include external input
Af = [A,zeros(2,1);zeros(1,2),0];
Bf = [B;0];
Cf = [eye(2),zeros(2,1)];
Df = zeros(2,1);

% Free Flight model
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,Tsz,'zoh');
dynFF = LTISystem(sysfd);

dynFF.setDomain('x', Polyhedron([0 0 1], 0));


% Docking model
Af(2,2) = DF_z_DC;
sysfc = ss(Af,Bf,Cf,Df);
sysfd = c2d(sysfc,Tsz,'zoh');
dynDC = LTISystem(sysfd);
dynDC.setDomain('x', Polyhedron([0 0 -1], 0));


modelZdirection = PWASystem([dynFF dynDC]);



% Set constraints on states and input
modelZdirection.x.min = [-1;-1;-1];
modelZdirection.x.max = [1;1;0.5];
modelZdirection.u.min = -1;
modelZdirection.u.max = 1;

% Set the penalty
Qxz = zeros(2,2);
Qxz(1,1) = 400; % position control   %400
Qxz(2,2) = 125;                      %125
Rz = 3;

modelZdirection.y.penalty = Penalty(Qxz,norm);
modelZdirection.u.penalty = Penalty(Rz,norm);

ctrlZ = MPCController(modelZdirection,12);

expmpcZdirection = ctrlZ.toExplicit;
exportToC_MLD(expmpcZdirection,Tsz,'ZdirectionCtrl','Zdirection');
cd Zdirection
mex mpt_getInput_sfunc_Zdirection.c;
cd ..
[Hn_Zdir,Kn_Zdir,Fi_Zdir,Gi_Zdir,Nc_Zdir] = GetMPCMatrices(expmpcZdirection);
save('Zdirection','Hn_Zdir','Kn_Zdir','Fi_Zdir','Gi_Zdir','Nc_Zdir');


%%
%------------------------------------------------------------
%------------------------------------------------------------
% Yaw Controller
%------------------------------------------------------------
%------------------------------------------------------------

Ay = -a0_yaw;
By = c0_yaw;
Cy = 1;
Dy = 0;

syscy = ss(Ay,By,Cy,Dy);

% All controller must operate at the same frequency
sysdy = c2d(syscy,TsReal,'zoh');
modelYaw = LTISystem(sysdy);

% Real models are generated at 50Hz frequency
sysdy = c2d(syscy,TsReal,'zoh');
modelYawReal = LTISystem(sysdy);

% Set constraints on states and input
modelYaw.x.min = -pi;
modelYaw.x.max = pi;
modelYaw.u.min = -pi;
modelYaw.u.max = pi;

% Set the penalty
Qxy= 100; % yaw angle control

%   Modifying George Penalization
Qxy = 80;

Ry = 15;

modelYaw.x.penalty = Penalty(Qxy,norm);
modelYaw.u.penalty = Penalty(Ry,norm);

ctrlYaw = MPCController(modelYaw,N);

expmpcYaw = ctrlYaw.toExplicit;
exportToC_MLD(expmpcYaw,TsCtrl,'YawCtrl','YawControl');
cd YawControl
mex mpt_getInput_sfunc_YawCtrl.c;
cd ..
[Hn_Yaw,Kn_Yaw,Fi_Yaw,Gi_Yaw,Nc_Yaw] = GetMPCMatrices(expmpcYaw);
save('Yawdirection','Hn_Yaw','Kn_Yaw','Fi_Yaw','Gi_Yaw','Nc_Yaw');